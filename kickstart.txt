DOCUMENTATION:
--------------
Cela pourrait etre utile: telecharger la doc de django,
pour pouvoir la lire meme quand il n'y pas d'internet,
ce qui est frequent dans notre cher continent de merde.

- telecharger le zip de la version stable
- installer python-setuptools via apt et simplejson, sphinx via pip
- extraire le repertoire docs
- entrer ds le repertoire docs et faire make html
- la doc se trouve ds le repertoire _build/html


- installer sqlite3, avant de compiler python3:
sudo apt-get install libsqlite3-dev sqlite-doc uwsgi-plugin-python build-essential

recuperer python3
wget

installer python3
./configure
make
make test
make install

installer des dependance pour PIL:
apt-get install libjpeg-dev
apt-get install zlib1g-dev
apt-get install libpng12-dev

creer un virtualenv
virtualenv -p python3.4 envs/wappa

activer le virtualenv et installer
django
selenium
pysqlite? not if aptitude installed libsqlite3-dev
sphinx


CREER UN PROJET DJANGO
----------------------
django-admin.py startproject

et a l'interieur du projet django:
- creer un repertoire pour les test fonctionnels
- a l'interieur de ce dernier, creer un fichier all_users.py

ce fichier contiendra tous les tests fonctionnels

- creer un repertoire requirements
- a l'interieur de ce dernier, creer les fichiers textes:
base, dev, prod, test

cela equivaut a 4 virtualenvs differents, en fonction du contexte.
Cela signifie egalement que nous devrions avoir 4 virtualenvs, et non 1,
tous les fichiers heriteront de base.txt

django creera par defaut un seul fichier settings.py.
A cote de ce fichier, nous allons creer un repertoire settings,
et a l'interieur de ce repertoire, creer les fichiers:
- base.py
- prod.py
- test.py
- dev.py
- __init__.py

cela equivaut a une configuration, en fonction du contexte.
Tous les fichier, heriteront de la configuration se trouvant dans base.py

Pour executer django avec une configuration particuliere,
on aura deux options

la premiere, preciser la config en ligne de commande:
$ python manage.py runserver --settings=wappa.settings.base

la seconde, definir une variable d'env utilisée par notre virtualenv:
- export DJANGO_SETTINGS_MODULE=wappa.settings.dev
- unset DJANGO_SETTINGS_MODULE

et plus besoin d'utiliser l'option --settings.
Faudra egalement voir comment automastier la creation de la varenv

dans les fichiers de configuration dev.py et test.py
DEBUG = True
TEMPLATE_DEBUG = True

dans le fichier de config prod.py
DEBUG = False
TEMPLATE_DEBUG = False

la cle secret ne doit pas apparaitre dans la configuration
il faudra donc supprimer la variable SECRET_KEY du fichier de config
base.py et la remplacer par une fonction lisant une varenv

from django.core.exceptions import ImproperlyConfigured

def get_env_variable(var_name):
    try:
        return os.environ[var_name]
    except KeyError:
        error_msg = "Set the %s environment variable" % var_name
        raise ImproperlyConfigured(error_msg)

SECRET_KEY = get_env_variable('SECRET_KEY')

Et donc:
en demarrant le virtualenv, il faudra faire
export SECRET_KEY=uneclésecrete

en desactivant le virtualenv, il faudra avant faire
unset SECRET_KEY

autre maniere de definir une cle secret, est de l'ecrire dans un fichier,
ce fichier ne doit pas etre versionné par git
- creer un fichier secret.txt dans le repertoire settings
- a l'interieur de ce fichier, coller la cle secret 'laclesecret'
- a l'interieur de base.py recuperer la cle secret en faisant:

def get_secret_from_file(secret_file):
    try:
        return open(os.path.join(BASE_DIR, secret_file)).read().strip()
    except KeyError:
        error_msg = "Secret file %s missing" % secret_file
        raise ImproperlyConfigured(error_msg)

SECRET_KEY = get_secret_from_file('settings/secret.txt')

Definir l'url via laquelle les fichiers statics seront servis.
modifier le fichier de configuration de base et ajouter:

STATIC_URL = '/static/'

Definir le repertoire dans lequel seront versés les fichiers
statiques. a l'appel de l'url plus haut, quel est le repertoire
où aller chercher les fichiers statiques? modifier le fichier
de configuration de base et ajouter:

STATICFILES_DIRS = (
    os.path.join(BASE_DIR, "static"),

)

Dans le repertoire "static", mettre les repertoire js, css, img.
eventuellement, un favicon.ico

il faudra ensuite appeler python manage.py collectstatic,
lorsque l'on sera en production.


Definir le repertoire dans lequel se trouvera tout le html. et un robot.txt.
Django cherchera un repertoire templates au niveau du projet,
puis au niveau de chaque application.

TEMPLATE_DIRS = (
    os.path.join(BASE_DIR, "templates"),

)

Les repertoires "templates" et "static" doivent exister,
au meme niveau que le repertoire "settings"

Transformer le repertoire functional_tests en module, en y
mettant un fichier vide nommé __init__.py
Ainsi, nous executerons les tests en tapant
python manage.py test functional_tests

tous les fichiers de tests a l'interieur du repertoire functiona_tests,
doivent etre prefixés par "test_"


CREATION DU MODELE DE DONNÉES:
------------------------------
Premiere chose, créer une application.
Toutes les applications de notre projet seront placées ds le repertoire apps.
ce repertoire se trouve au meme niveau que le fichier manage.py.

creer une application a la racine du projet:
python manage.py startapp photo

deplacer cette application dans le repertoire apps:
mv photo apps/; touch apps/__init__.py

puis editer le fichier de configuration base.py,
dans le tuple installed apps, ajouter une ligne: 'apps.photo', ainsi, django
sait qu'il doit tenir compte de la nouvelle application.

s'assurer que la racine du projet se trouve dans le python path,
autrement, django ne sera pas capable de reconnaitre le repertoire apps
comme etant un module

# the directory containing the manage.py file
ROOT_DIR = os.path.abspath(os.path.join(BASE_DIR, os.pardir))

# add ROOT_DIR to the python path
import sys
sys.path.append(ROOT_DIR)


le processus sera a peu pres le suivant:

editer le fichier models.py # pour mettre a jour le modele de données
python manage.py makemigrations # pour creer le script de migration
python manage.py migrate # pour appliquer les migration et ainsi modifier la bdd

Ensuite, il nous faut créer un admin, pour le backoffice:
python manage.py createsuperuser # a executer une et une seule fois bien sur :)


GESTION DES UPLOADS D'IMAGES:
-----------------------------
Voici la config a ajouter ds le fichier base.py

# Media files ( user uploaded contents)
# https://docs.djangoproject.com/en/1.7/ref/settings/#std:setting-MEDIA_ROOT
MEDIA_ROOT = "/var/www/wappa/media/"
MEDIA_URL = "/media/"

MEDIA_ROOT est le chemin vers le repertoire qui sera utilisé pour recevoir
les fichiers uploadés. Ce chemin doit exister et doit etre writable.

MEDIA_URL est l'url qui sera utilisée pour acceder a MEDIA_ROOT via http.
Doit toujours se terminer par un /

Pour servir des fichiers uploadés par les clients en mode DEBUG=True,
il suffit de modifier le fichier url.py et y ajouter:

from django.conf import settings
from django.conf.urls.static import static

urlpatterns = patterns('',
    # ... the rest of your URLconf goes here ...
    ) + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)



FIXTURES:
---------
- creer un repertoire fixtures dans chaque application
- a l'interieur de ce repertoire, placer un fichier initial_data.json
- a l'interieur de ce fichier, ecrire du json decrivant les données a inserer a chaque migrations
Par defaut, django ira chercher dans chaque application, le fameux fichier initial_data.json
et ensuite tentera d'inserer ces données ds les tables qu'il faut.

Il est egalement possible de sauvegarder une bdd dans un fichier fixtures.
- python manage.py dumpdata photo --format json --indent 2 --natural-foreign > path/to/initial_data.json
Ce qui permet par exemple d'echanger la bdd entre devs de la meme equipe.
Ces derniers devront faire:
- python manage.py loaddata path/to/initial_data.json
et les données seront inserées ds la bdd

Enfin, il est egalement possible de definir un repetoire fixtures custom.
Il suffit de modifier le fichier base.py en y ajoutant quelque chose comme:
FIXTURE_DIRS = (
    normpath(join(SITE_ROOT, 'fixtures')),

)
Et ainsi, plus besoin de preciser le chemin a chaque fois que l'on veut importer


INTERNATIONALIZATION / LOCALIZATION
-----------------------------------
i18n: art de preparer le projet a la localisation.
l10n: ecrire les traductions

s'assurer d'avoir installé gettext.
http://ftp.gnu.org/pub/gnu/gettext/gettext-0.19.3.tar.xz

modifier le fichire base.py et veiller a avoir la ligne:
USE_I18N = True

Pour configurer l'internationalization, il faut egalement
configurer les template_context_processors. Ou pas,
django en utilise deja certains par defaut, si rien n'est
defini ds base.py

("django.contrib.auth.context_processors.auth",
"django.core.context_processors.debug",
"django.core.context_processors.i18n",
"django.core.context_processors.media",
"django.core.context_processors.static",
"django.core.context_processors.tz",
"django.contrib.messages.context_processors.messages")

Il n'y a donc rien a faire, si ce n'est verifier en
lançant une console python et afficher la valeur par
defaut:

$ python manage.py shell
>>> from django.conf import settings
>>> settings.TEMPLATE_CONTEXT_PROCESSORS

les templates context processors nous aideront
a ecrire des tags que nous utiliserons ds les
templates. exemple, ecrire un tag qui recupere
une variable ds le fichier settings. nous y
reviendrons.

toujours pour configurer i18n/l10n,
veiller a ce que le middleware Locale soit là.
Il faut veiller a le placer apres sessionmidleware
et avant commonmiddleware car l'ordre importe.
Et si cachemiddleware est present, localemiddleware
doit etre placé apres.

MIDDLEWARE_CLASSES = (
  ...
  'django.middleware.locale.LocaleMiddleware'
)

Les middlewares permettent d'alterer le cycle
requete/reponse de django grace a des hooks.

specifier egalement les langages dans lesquels
on va faire les traductions

from django.utils.translation import ugettext_lazy as _
# http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
LANGUAGES = (
    ('en', _('English')),
    ('de', _('German')),
    ('fr', _('French')),
)

Ici, la fonction underscore alias de la fonction
ugettext_lazy, est utilisée pour "marquer" le nom
de la langue pour traduction. ugettext_lazy ne fera
de traductions qu'au moment de rendre le template

si aucune traduction trouvée,
traduction par defaut: utiliser en
LANGUAGE_CODE = 'en-us'

# le chemin vers le repertoire contenant les trads
LOCALE_PATHS = (
    os.path.join(BASE_DIR, 'locale'),

)

Ensuite, il faut mettre a jour le fichier urls.py

from django.conf.urls import patterns, include, url
from django.contrib import admin
from django.conf.urls.i18n import i18n_patterns
from apps.photo.views import home, home_files

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'wappa.views.home', name='home'),
    # url(r'^blog/', include('blog.urls')),
    url(r'^(?P<filename>(robots.txt)|(humans.txt))$',
                        home_files,name='home-files'),
                        )

urlpatterns += i18n_patterns(
    '',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^$', home, name='home'),
)

en gros, les urls admin/ et / vont etre gerée de
maniere automagique. / deviendra /en/ par defaut,
et admin/ deviendra /en/admin/ par defaut.
Parce que mon navigateur prefere naviger en anglais.

Sur un navigateur preferant naviguer en français,
le prefixe fr/ sera ajouté a la place de en/

Dans le cas où le navigateur ne donne pas sa preference,
LANGUAGE_CODE determinera la langue a utiliser.

les urls que nous voulons soumettre a la traduction
doivent etre misent ds le tuple i18n_patterns

les fichiers robots et humans ne seront pas soumis
a cette gestion automagique d'urls.

Pour generer les fichiers contenant les traductions.
Se mettre a la racine du projet a cote de manage.py
et taper:

python manage.py makemessages -l en
python manage.py makemessages -l fr
python manage.py makemessages -l de

Il faut lancer ces commandes chaque fois que l'on ajoute
un nouveau mot n'etant pas encore traduit.
Ensuite, aller editer ces fichier pour definir les bonnes traductions

J'utilise une version de django ayant un leger bug.
le bug a deja ete fixé, je dois mettre a jour django.
Pour que les trois commandes precedentes fonctionnent,
en attendant de maj django, je dois avoir dans base.py

STATIC_ROOT = '/var/www/wappa/static/'

Les fichiers de traductions sont tous dans:

wappa/locales/en/LC_MESSAGES/django.po
wappa/locales/fr/LC_MESSAGES/django.po
wappa/locales/de/LC_MESSAGES/django.po

Django recommande l'installation de pytz, pour permettre le
calcul de temps: allows accurate and cross platform timezone calculations.
donc: pip install pytz et ensuite mise a jour du fichier base.txt

Le support pour les fuseau horaire a ete activé par USE_TZ = True
et donc, toutes les dates de notre systeme sont capable de reconnaitre
le fuseau horaire.

import datetime
from django.utils.timezone import utc

now_naive = datetime.datetime.now()
now_aware = datetime.datetime.utcnow().replace(tzinfo=utc)

now_naive ne sait pas quel est le fuseau horaire
now_aware sait quel est son fuseau horaire.
les fonctions is_aware() et is_naive() permettent de tester une date
afin de savoir si cette derniere sait quel est son fuseau horaire.

etant donné que USE_TZ = True dans notre config,
pour avoir la date, il vaut mieux toujours faire

from django.utils.timezone import now
now_aware = now()

Definition du fuseau horaire par defaut, dans notre cas, afrique/dakar
TIME_ZONE = 'Africa/Dakar', cette valeur devra etre mise a jour

ATTRIBUTS TRADUCTIBLES
----------------------
faire en sorte que certains attribut de mon modele puissent etre
traduits en fonction de l'url visitée.

installation: pip install django-hvad
mise a jour de base.py, modification du tuple INSTALLED_APPS
hvad soit etre parmi les appli installées.

modification de models.py
Il faut effectuer un import:
from hvad.models import TranslatableModel, TranslatedFields
- les classes doivent heriter de TranslatableModel
- les champs devant etre traduits doivent etre du type TranslatedFields.

modification de admin.py
Effectuer les imports suivant:
from hvad.admin import TranslatableAdmin
from django.utils.translation import ugettext_lazy as _

Les classes devant etre modifiées ds l'admin doivent heriter de TranslatableAdmin.
Et les fieldsets doivent etre modifiés a peu pres comme suit:

On va mettre d'un cote les fields devant etre traduits,
et d'un autre ceux ne devant pas etre traduits.
Puis on va dire a l'admin d'utiliser cette organisation des fields.

class PackModelAdmin(TranslatableAdmin):
    use_fieldsets = (
        (_("Common"), {
            'fields': ('domain', 'country', 'image',
                       'date published', 'pack_type', 'status',)
            }),
        (_("Language dependent"), {
            'fields': ('label', 'description',),

            }),
        )

    def get_fieldsets(self, request, obj=None):
        return self.use_fieldsets

admin.site.register(Pack, PackModelAdmin)

hvad vient avec une serie de templates qu'il faudra deplacer
dans notre repertoire de templates afin de les customizer:

notre repertoire templates contient un repertoire par application.
chaque repertoire porte exactement le nom de l'application pour laquelle les templates y sont definis.
templates/admin pour l'appli admin de django
templates/photo pour notre application photo
templates/admin/hvad pour l'appli hvad que l'on a installé plus haut <-- subtil


DJANGO TAGGIT
-------------
http://django-taggit.readthedocs.org/en/latest/forms.html

- pip install django-taggit
- mise a jour de INSTALLED_APPS: ajouter 'taggit'
- mise a jour du modele: from taggit.managers import TaggableManager
- ajout du champ tag ds une classe: tags = TaggableManager()
- veiller a mettre a jour le fichier admin.py si necessaire

effectuer des recherches avec filtres:
http://django-taggit.readthedocs.org/en/latest/api.html


Pour faire en sorte que les tags soient disponibles au niveau des templatestags:
https://github.com/feuervogel/django-taggit-templatetags


DJANGO ENVOYER DES FICHIERS DANS UN BUCKET AS3
----------------------------------------------
- pip install boto


CUSTOM USER MODEL
-----------------
ou comment definir la classe a utiliser pour definir un utilisateur.
https://docs.djangoproject.com/en/1.7/topics/auth/customizing/#extending-the-existing-user-model


DJANGO CELERY:
--------------
- pip install celery
- ajout d'un fichier celery.py juste a cote du fichier urls.py principal
- contenu du fichier celery.py:

from __future__ import absolute_import
import os
from celery import Celery
from django.conf import settings

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'proj.settings')
app = Celery('proj')

# Using a string here means the worker will not have to
# pickle the object when using Windows.
app.config_from_object('django.conf:settings')
app.autodiscover_tasks(lambda: settings.INSTALLED_APPS)

@app.task(bind=True)
def debug_task(self):
    print('Request: {0!r}'.format(self.request))


Ensuite, modifier le fichier __init__.py se trouvant au meme niveau:

from __future__ import absolute_import

# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

Veiller egalement a modifier le fichier base.py, pour y inclure
la configuration relative a celery:

BROKER_URL = 'redis://localhost:6379/0'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'

Ne pas oublier d'installer redis
- aptitude install redis-server
- pip install redis

La commande pour lancer le gestionnaire de taches:
$ celery -A wappa worker -l info

Derniere chose, ecrire les taches de notre application
a l'interieur d'un fichier tasks.py se trouvant au meme niveau
que models.py:

from celery.task import Task
from celery.registry import tasks

import sys
import boto
import boto.s3
from boto.s3.key import Key


class UploadToAS3(Task):

    # AWS ACCESS DETAILS
    AWS_ACCESS_KEY_ID = ''
    AWS_SECRET_ACCESS_KEY = ''

    # a bucket per author maybe
    bucket_name = 'web-application-photo-bucket'
    conn = boto.connect_s3(AWS_ACCESS_KEY_ID,
                        AWS_SECRET_ACCESS_KEY)
    #bucket = conn.create_bucket(bucket_name,
    #                            location=boto.s3.connection.Location.DEFAULT)

    # retrieve the bucket owned by me
    bucket = conn.get_bucket(bucket_name)

    def percent_cb(complete, total):
        sys.stdout.write('.')
        sys.stdout.flush()
        #pass

    def run(self, uploadfile, **kwargs):
        f = os.path.join(settings.MEDIA_ROOT, uploadfile)
        k = Key(self.bucket)
        # the key, should be the file name
        k.key = str(uploadfile)
        # the key value
        k.set_contents_from_filename(str(f))

class ReduceImageSize(Task):
    def run(self, uploadfile, **kwargs):
        pass


class RemoveOriginalImage(Task):
    def run(self, **kwargs):
        pass

tasks.register(MyTask)

Juste au dessus, c'est le contenu du fichier tasks.py,
ne pas oublier de lancer le service celery: celery -A wappa worker -l info
La meilleure chose etant de lancer le service via supervisord.

SUPERVISOR
----------
- installation sur une debian: aptitude install supervisor
- fichier de config /etc/supervisor/supervisor.conf
- fichier de config pour notre service: /etc/supervisor/conf.d/celerybeat.conf

a l'interieur de notre fichier:

[program:celerybeat]
; Set full path to celery program if using virtualenv
command=/home/patrick/envs/wappa/bin/celery -A wappa worker -l info

; root of the project, where to chdir
directory=/home/patrick/wappa1

; activate virtualenv
;environment=PATH="/home/patrick/envs/wappa/bin"

; set an environment variable
environment=DJANGO_SETTINGS_MODULE="wappa.settings.base" ; (key value pairs to add to environment)

;user=nobody
user=patrick

numprocs=1
stdout_logfile=/var/log/celery/beat.log
stderr_logfile=/var/log/celery/beat.log
autostart=true
autorestart=true
startsecs=10
redirect_stderr=true
stopsignal=QUIT

Une fois le fichier edité:
- supervisorctl reread
- supervisorctl update
- supervisorctl

Ça devrait fonctionner tranquillement.

Ensuite, il faut pouvoir appeler notre tache celery quand on veut.
Generalement, cela se fera a l'interieur d'une view, apres avoir validé un formulaire,
ou vien apres avoir verifié certaines conditions.

Nous ce qu'on desire c'est envoyer une image sur AS3, juste apres l'upload.
On va donc modifier notre admin.py et redefinir la fonction save ainsi.

#!/usr/bin/env python
# -*- coding:utf-8 -*-

from django.contrib import admin
from apps.photo.models import Photo, Pack
from apps.photo.tasks import UploadToAS3

from hvad.admin import TranslatableAdmin
from django.utils.translation import ugettext_lazy as _

class PhotoModelAdmin(TranslatableAdmin):
    use_fieldsets = (
        (_("Common"), {
            'fields': ('pack', 'country', 'image',
                       'date published', 'status',)
            }),
        (_("Language dependent"), {
            'fields': ('label', 'description', 'tags',),
            }),
        )

    def get_fieldsets(self, request, obj=None):
        return self.use_fieldsets

    def save_model(self, request, obj, form, change):
        obj.save()
        UploadToAS3.delay(obj.image.name)


L'importante modification est la definition de la methode save_model,
a l'interieur, on sauvegarde notre objet et juste apres, on appelle notre tache.
La tache attend en argument, le chemin vers une image et sera non bloquante.

Creation d'une application Taxonomy, pour gerer tout ce qui est categorisation
------------------------------------------------------------------------------

A l'interieur de cette application, 4 modeles:
- country: le pays auquel est lié le pack
- status: le status, offline, online
- domain: le domaine auquel appartient un pack
- gender: le type d'un pack


Modification des models pack et photo, etre capable pour chaque objet de type pack ou photo,
de retrouver l'url admin de modification.

def get_change_urls(self):
    content_type = ContentType.objects.get_for_model(self.__class__)
    return urlresolvers.reverse("admin:%s_%s_change" % (content_type.app_label, content_type.model), args=(self.id,))


TEMPLATING:
-----------

debugger les templates
----------------------
- pip install django-template-debug.
- mettre dans le settings TEMPLATE_DEBUG=True
- mettre dans le template a debugger: {% load debug_tags %}
- ensuite:

{% set_trace %}: je comprend pas comment ça marche.

{% attributes <variable_name> %}: liste des attributs d'une variable.

{% variables %}: liste des variables dans le template.

{% details <variable_name> %}: dictionnaire contenant les attributs:valeurs pour une variable donnée.


Le bloc suivant dans change_form.html est en charge de l'affichage des onglets fr et en.
----------------------------------------------------------------------------------------

{% block object-tools %}
{% if change %}{% if not is_popup %}
  <ul class="object-tools">
    {% block object-tools-items %}
    <li>
        {% url opts|admin_urlname:'history' original.pk|admin_urlquote as history_url %}
        <a href="{% add_preserved_filters history_url %}" class="historylink">{% trans "History" %}</a>
    </li>
    {% if has_absolute_url %}<li><a href="{{ absolute_url }}" class="viewsitelink">{% trans "View on site" %}</a></li>{% endif%}
    {% endblock %}
  </ul>
{% endif %}{% endif %}
{% endblock %}



le bloc suivant dans change_list.html est en charge d'afficher le bouton ajouter
----------------------------------------------------------------------------------

{% block object-tools %}
  {% if has_add_permission %}
    <ul class="object-tools">
      {% block object-tools-items %}
        <li>
          {% url cl.opts|admin_urlname:'add' as add_url %}
          <a href="{% add_preserved_filters add_url is_popup to_field %}" class="addlink">
            {% blocktrans with cl.opts.verbose_name as name %}Add {{ name }}{% endblocktrans %}
          </a>
        </li>
      {% endblock %}
    </ul>
  {% endif %}
{% endblock %}





Django pages statiques:
-----------------------
simple, modifier le fichier url.py et ajouter les routes vers les fichiers statiques:
url(r'^about',
    TemplateView.as_view(template_name='path/to/about_us.html'),
    name='about'),

ou bien utiliser les flatpages:
https://docs.djangoproject.com/en/1.7/ref/contrib/flatpages/


DOCUMENTATION DU PROJET AVEC SPHINX
-----------------------------------
- pip install sphinx
- sphinx-quickstart


CUSTOMISER LA HOME PAGE DE DJANGO ADMIN
---------------------------------------
editer les fichiers:
- admin/app_index.html
- admin/index.html

CUSTOMISER LES TEMPLATES UTILISÉS PAR LES MODELES:
--------------------------------------------------
En bref, il suffit d'ecrire soit meme ses templates, et de passer au ModelAdmin,
le chemin vers les templates customs.
Pour chacune des classes a l'interieur du fichier admin.py, redefinir les attributs:
add_form_template = "admin/photo/add_status_form.html"
change_form_template = "admin/photo/change_status_form.html"
change_list_template = "admin/photo/change_status_list.html"
delete_confirmation_template = None
delete_selected_confirmation_template = None
object_history_template = None


POUR SERVIR UNE IMAGE UPLOADÉE PAR UN USER, UNIQUEMENT EN MODE DEBUG:
---------------------------------------------------------------------

- modifier le fichier urls.py
from django.conf import settings
from django.conf.urls.static import static

- et a la suite des urls existantes, ajouter:
if settings.DEBUG == True:
    urlpatterns = urlpatterns + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

- a l'interieur du template:
<li><img src="{{ MEDIA_URL }}{{ a.image }}" alt="My image"/></li>
<li><img src="{{ a.image.url }}" alt="{{ a.description }}"/></li>


CREATION DE THUMBNAILS A LA VOLEE:
----------------------------------
- pip install django-imagekit
- ajouter imagekit au tuple installed_app dans settings/base.py
- dans le template:
<li>{% thumbnail '100x50' a.image %}</li>

ou bien:
{% with source_file = a.image %}
<li>{% thumbnail '100x50' source_file %}</li>
{% endwith %}


AJOUTER UNE NOUVELLE URL A L'ADMIN INTERFACE:
---------------------------------------------
- redefinir la methode get_url de notre ModelAdmin et lui passer l'url custom:

    def get_urls(self):
        urls = super(PackModelAdmin, self).get_urls()
        custom_urls = patterns('',
                               url(r'(?P<pack_id>\d+)/remove_photo/(?P<photo_id>\d+)/$',
                                self.admin_site.admin_view(self.remove_photo_from_pack),
                                name='rpfp'),
                                )
        return custom_urls + urls

- ensuite, definir la vue appelée lorsque l'url custom sera invoquée:

    def remove_photo_from_pack(self, request, photo_id, pack_id):
        messages.add_message(request, messages.SUCCESS, _('photo removed from pack with success.'))
        photo = Photo.objects.get(pk=photo_id)
        Pack.objects.get(pk=pack_id).photos.remove(photo)
        return HttpResponseRedirect(urlresolvers.reverse("admin:photo_pack_change",args=(pack_id,)))

- et ensuite, invoquer la vue depuis un template:
<a href="{% url 'admin:photo_photo_change' a.id %}">{% blocktrans %}update {% endblocktrans %}</a>
<a href="{% url 'admin:rpfp' photo_id=a.id pack_id=current_pack.id %}">{% blocktrans %}rpfp {% endblocktrans %}</a>


DANS LE TEMPLATE COMMENT ACCEDER A L'OBJET FORM VENANT DE L'ADMIN INTERFACE:
----------------------------------------------------------------------------
- si on considere que l'entité du modele possede un attribut 'title':
{{ adminform.form.title.label_tag }}: {{ adminform.form.title }}



MODIFIER LE NOM DE L'IMAGE FRAICHEMENT UPLODEE:
-----------------------------------------------
- modifier l'attribut image de la classe Photo:
image = models.ImageField(max_length=200, upload_to=content_file_name)

- definir la fonction content_file_name
    # function called after the save function is called to rename image filename
    def content_file_name(instance, filename):
        fname, fext = os.path.splitext(filename)
        filename = "%s_%s_%s%s%s%s" % (instance.author_id,
                                        instance.id,
                                        instance.width, "x", instance.height,
                                        fext)
        full_filename = os.path.join('wappa', filename)
        # remove file if exists
        if os.path.isfile(os.path.join(settings.MEDIA_ROOT, full_filename)):
            os.remove(os.path.join(settings.MEDIA_ROOT, full_filename))
        return full_filename

- modifier la fonction save de la classe pour qu'elle soit appelée deux fois:
def save(self, *args, **kwargs):
    # save image, to set the id object
    if self.id is None:
        tmp_img, self.image = self.image, None
        super(Photo, self).save(*args, **kwargs)
        self.image = tmp_img

    # self.image has changed, so save is called again
    super(Photo, self).save(*args, **kwargs)


MODIFIER LA MANIERE DONT LE FIELD SERA RENDU DANS LE HTML
---------------------------------------------------------
Dans le modele, on a cet attribut:
image = models.ForeignKey(Photo, null=True, blank=True, verbose_name=_('image preview'))

Dans la vue, cet attribut est rendu en utilisant une dropdownlist.
Pour modifier ce comportement, il faut:
- redefinir l'objet "formulaire" utilisé par l'admin.
- dans ce formulaire, redefinir l'objet "widget" utilisé pour rendre l'attribut image.

Ici, on demande a notre attribut d'etre rendu en utilisant un simple input de type texte.

# PackAdminForm se trouve dans admin.py, mais peut bien etre ailleurs
class PackAdminForm(TranslatableModelForm):
    class Meta:
        model = Pack
        widgets = {
             'image': forms.TextInput(),
             }

- Une fois le formulaire redefini, il faut l'appeler dans la class admin:

# PackModelAdmin se trouve dans admin.py
class PackModelAdmin(TranslatableAdmin):
    form = PackAdminForm

PS: on ne redefinit qu'un seul attribut, les autres utiliseront les widgets par defaut.


FAIRE EN SORTE QUE LE CHAMP D'UN FORM NE SOIT PAS REQUIS:
---------------------------------------------------------
- redefinir la fonction __init__ de la classe de type Form
- la ligne importante etant: self.fields['wtfname'].required = False

class PackAdminForm(TranslatableModelForm):
    def __init__(self, *args, **kwargs):
        super(TranslatableModelForm, self).__init__(*args, **kwargs)
        self.fields["wtfname"].required = False

    wtfname = forms.CharField(help_text="Please enter the category name.",
                              min_length=None,
                              max_length=None)

Ainsi, lorsque le formulaire sera rendu dans le html,
le poster, sans remplir le champ wtfname, ne declenchera pas d'erreur a la validation.


DEFINITION D'UN FILTRE CUSTOM QUI SERA UTILISÉ DANS LE CHANGELIST DE L'ADMIN INTERFACE
--------------------------------------------------------------------------------------

class StatusFilter(SimpleListFilter):
    title = _('status')
    parameter_name = 'name'

    def lookups(self, request, model_admin):
        statuses = set([p.status for p in model_admin.model.objects.all()])
        return [(s.id, s.lazy_translation_getter('name', str(s.id))) for s in statuses]
        # You can also use hardcoded model name like "Country" instead of
        # "model_admin.model" if this is not direct foreign key filter

    def queryset(self, request, queryset):
        if self.value():
            return queryset.filter(status__id__exact=self.value())
        else:
            return queryset

la methode lookups va renvoyer ce sur quoi on veut faire le filtre dans le changelist.
la methode queryset est celle qui sera executée lorsque l'on clique sur un des filtres.

Pour inserer le filtre dans la classe PackModelAdmin:
class PackModelAdmin(ModelAdmin):
    list_filter = (StatusFilter,)

EXEMPLE MANIPULATION OBJET POSSEDANT CHAMP DE TYPE IMAGEFIELD:
--------------------------------------------------------------
>>> from apps.photo.models import Photo
>>> p = Photo.objects.language('en').first()
>>> p.label
'a picture'
>>> p.image
<ImageFieldFile: wappa/ace.png>
>>> dir(p.image)
['DEFAULT_CHUNK_SIZE', '__bool__', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__enter__', '__eq__', '__exit__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__module__', '__ne__', '__new__', '__nonzero__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_committed', '_del_file', '_file', '_get_closed', '_get_file', '_get_height', '_get_image_dimensions', '_get_path', '_get_size', '_get_url', '_get_width', '_require_file', '_set_file', '_set_size', 'chunks', 'close', 'closed', 'delete', 'encoding', 'field', 'file', 'fileno', 'flush', 'height', 'instance', 'isatty', 'multiple_chunks', 'name', 'newlines', 'open', 'path', 'read', 'readinto', 'readline', 'readlines', 'save', 'seek', 'size', 'softspace', 'storage', 'tell', 'truncate', 'url', 'width', 'write', 'writelines', 'xreadlines']
>>> p.image.name
'wappa/ace.png'
>>> import os
>>> os.path.abspath(p.image.name)
'/home/nsukami/envs/wappa/source/wappa/wappa/ace.png'
>>>


AUTRE EXEMPLE:
--------------
>>> p = Photo.objects.first()
>>> p.image
<ImageFieldFile: wappa/4f837950362ec_NcmvTiQ.jpg>
>>> p.url
Traceback (most recent call last):
  File "<console>", line 1, in <module>
  AttributeError: 'Photo' object has no attribute 'url'
>>> p.image.url
'/media/wappa/4f837950362ec_NcmvTiQ.jpg'


AUTRE EXEMPLE:
--------------
>>> from apps.photo.tasks import UploadToAS3
>>> from apps.photo.models import Photo
>>> p = Photo.objects.language('fr').first()
>>> i = p.image.name
>>> i
'wappa/AwGq7_rpyoyil.png'
>>> UploadToAS3.delay(i)
<AsyncResult: db7552b3-aebc-4140-9dc2-5004279528b9>
>>> import os
>>> r = UploadToAS3.delay(os.path.abspath(i))
>>> r
<AsyncResult: c8b1492a-e95e-4da3-a012-c924cbff3236>
>>>

RECUPERATION DU CHEMIN REEL VERS UNE IMAGE
------------------------------------------
>>> from apps.photo.models import Photo
>>> from django.conf import settings
>>> p = Photo.objects.language('fr').first()
>>> i = p.image.name
>>> i
'wappa/AwGq7_rpyoyil.png'
>>> settings.MEDIA_ROOT
'/var/www/wappa/media/'
>>> import os
>>> os.path.join(settings.MEDIA_ROOT, i)
'/var/www/wappa/media/wappa/AwGq7_rpyoyil.png'
>>>


MANIPULATION D'IMAGE AVEC PIL
--------------------------------
>>> import os
>>> from django.conf import settings
>>> from PIL import Image
>>> from apps.photo.models import Photo
>>> p = Photo.objects.language('fr').first()
>>> ii = p.image.name
>>> ii
'wappa/AwGq7_rpyoyil.png'
>>> i = os.path.join(settings.MEDIA_ROOT, ii)
>>> i
'/var/www/wappa/media/wappa/AwGq7_rpyoyil.png'
>>> ii = Image.open(i)
>>> dir(ii)
['_Image__transformer', '_PngImageFile__idat', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__enter__', '__eq__', '__exit__', '__format__', '__ge__', '__getattr__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_copy', '_dump', '_expand', '_makeself', '_new', '_open', 'category', 'close', 'convert', 'copy', 'crop', 'decoderconfig', 'decodermaxblock', 'draft', 'effect_spread', 'filename', 'filter', 'format', 'format_description', 'fp', 'frombytes', 'fromstring', 'getbands', 'getbbox', 'getcolors', 'getdata', 'getextrema', 'getim', 'getpalette', 'getpixel', 'getprojection', 'histogram', 'im', 'info', 'load', 'load_end', 'load_prepare', 'load_read', 'mode', 'offset', 'palette', 'paste', 'png', 'point', 'putalpha', 'putdata', 'putpalette', 'putpixel', 'pyaccess', 'quantize', 'readonly', 'resize', 'rotate', 'save', 'seek', 'show', 'size', 'split', 'tell', 'text', 'thumbnail', 'tile', 'tobitmap', 'tobytes', 'tostring', 'transform', 'transpose', 'verify']
>>>
>>> ii.resize((128, 128))
<PIL.Image.Image image mode=RGB size=128x128 at 0x7F9974D076D8>
>>> iout = ii.resize((128,128))
>>> outfile = os.path.splitext(i)[0]+"_thumbnail.png"
>>> iout.save(outfile, "PNG")
>>>
>>> # on peut egalement utiliser la fonction thumbnail
>>> ii.thumbnail((12, 12))
>>> ii.save(outfile, "PNG")
>>>

RETROUVER ADMIN URL POUR UN MODEL:
----------------------------------
>>> from django.contrib import admin
>>> dir(admin.site.urls)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index']
>>> type(admin.site.urls)
<class 'tuple'>
>>> admin.site.urls
([<RegexURLPattern index ^$>, <RegexURLPattern login ^login/$>, <RegexURLPattern logout ^logout/$>, <RegexURLPattern password_change ^password_change/$>, <RegexURLPattern password_change_done ^password_change/done/$>, <RegexURLPattern jsi18n ^jsi18n/$>, <RegexURLPattern view_on_site ^r/(?P<content_type_id>\d+)/(?P<object_id>.+)/$>, <RegexURLResolver <RegexURLPattern list> (None:None) ^auth/group/>, <RegexURLResolver <RegexURLPattern list> (None:None) ^auth/user/>, <RegexURLResolver <RegexURLPattern list> (None:None) ^photo/photo/>, <RegexURLResolver <RegexURLPattern list> (None:None) ^taggit/tag/>, <RegexURLResolver <RegexURLPattern list> (None:None) ^photo/pack/>, <RegexURLPattern app_list ^(?P<app_label>auth|photo|taggit)/$>], 'admin', 'admin')
>>>
>>>
>>> from django.core import urlresolvers
>>> from django.contrib.contentypes.models import ContentType
>>> from django.contrib.contenttypes.models import ContentType
>>> from apps.photo.models import Photo, Pack
>>> ct = ContentType.objects.get_for_model(Pack)
>>> ct.model
'pack'
>>> ct.app_label
'photo'
>>> urlresolvers.reverse("admin:photo_pack_change")
>>> help(urlresolvers.reverse)
>>> p = Pack.objects.first()
>>> p = Pack.objects.first()
>>> p.pk
1
>>> urlresolvers.reverse("admin:photo_pack_change", args=(p.pk,))
'/en-us/admin/photo/pack/1/'
>>> urlresolvers.reverse("admin:photo_pack_change", args=(1,))
'/en-us/admin/photo/pack/1/'
>>>


RECUPERER L'OBJET FORM DE L'ADMIN
---------------------------------
    def get_form(self, request, obj=None, **kwargs):
        form = super(PhotoModelAdmin, self).get_form(request, **kwargs)
        return form



COMMENT TESTER UNE VUE:
-----------------------

- dans une console python:
--------------------------

>>> from django.core import urlresolvers
>>> urlresolvers.reverse("admin:index")
'/en-us/admin/'
>>> urlresolvers.reverse("admin:login")
'/en-us/admin/login/'
>>> from django.test import Client
>>> c = Client()
>>> u = urlresolvers.reverse("admin:login")
>>> c.get(u)
<django.http.response.HttpResponseNotFound object at 0x7fe60069ada0>
>>> u = urlresolvers.reverse("admin:index")
>>> c.get(u)
<django.http.response.HttpResponseRedirect object at 0x7fe60053b198>
>>> r = c.get(u)
>>> dir(r)
['__bytes__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getstate__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_charset', '_closable_objects', '_container', '_convert_to_charset', '_handler_class', '_headers', 'allowed_schemes', 'client', 'close', 'content', 'context', 'cookies', 'delete_cookie', 'flush', 'get', 'has_header', 'items', 'make_bytes', 'reason_phrase', 'request', 'serialize', 'serialize_headers', 'set_cookie', 'set_signed_cookie', 'status_code', 'streaming', 'tell', 'templates', 'url', 'write', 'wsgi_request']
>>> r.url
'http://testserver/en/admin/login/?next=/en/admin/'
>>> r.status_code
302
>>> r.streaming
False
>>> r.request
{'REQUEST_METHOD': 'GET', 'wsgi.url_scheme': 'http', 'SERVER_PORT': '80', 'PATH_INFO': '/en/admin/', 'QUERY_STRING': `}
>>>


- dans un test unitaire:
------------------------

class BackOfficeViewsTest(TestCase):
    def setUp(self):
        self.client = Client()
        self.credentials = {'username':'patrick',
                            'password':'patrick'}
        # a user should exist to test login
        User.objects.create_user(**self.credentials)

    def test_get_login(self):
        #url = reverse("admin:index")
        #resp = self.client.get(url, follow=True)
        resp = self.client.get("/admin/login/", follow=True)
        self.assertRedirects(resp, '/fr/admin/login/')
        self.assertEqual(resp.status_code, 200)
        self.assertTemplateUsed(resp, "admin/login.html")
        #self.assertIn("", resp.content)

    def test_post_login(self):
        self.client.login(**self.credentials)
        resp = self.client.post("/admin/login/", follow=True)
        self.assertRedirects(resp, '/fr/admin/login/')
        self.assertEqual(resp.status_code, 200)
        # should be logged in now, fails however
        self.assertTrue(resp.context['user'].is_active)
