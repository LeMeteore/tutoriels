DOCUMENTATION:
--------------
Cela pourrait etre utile: telecharger la doc de django,
pour pouvoir la lire meme quand il n'y pas d'internet,
ce qui est frequent dans notre cher continent de merde.

- telecharger le zip de la version stable
- installer python-setuptools via apt et simplejson, sphinx via pip
- extraire le repertoire docs
- entrer ds le repertoire docs et faire make html
- la doc se trouve ds le repertoire _build/html


installer sqlite3, avant de compiler python3
sudo apt-get install libsqlite3-dev sqlite-doc uwsgi-plugin-python build-essential

recuperer python3
wget

installer python3
./configure
make
make test
make install

creer un virtualenv
virtualenv -p python3.4 envs/wappa

activer le virtualenv et installer
django
selenium
pysqlite? not if aptitude installed libsqlite3-dev
sphinx

creer un projet django
django-admin.py startproject

et a l'interieur du projet django:
- creer un repertoire pour les test fonctionnels
- a l'interieur de ce dernier, creer un fichier all_users.py

ce fichier contiendra tous les tests fonctionnels

- creer un repertoire requirements
- a l'interieur de ce dernier, creer les fichiers textes:
base, dev, prod, test

cela equivaut a 4 virtualenvs differents, en fonction du contexte.
Cela signifie egalement que nous devrions avoir 4 virtualenvs, et non 1,
tous les fichiers heriteront de base.txt

django creera par defaut un seul fichier settings.py.
A cote de ce fichier, nous allons creer un repertoire settings,
et a l'interieur de ce repertoire, creer les fichiers:
- base.py
- prod.py
- test.py
- dev.py
- __init__.py

cela equivaut a une configuration, en fonction du contexte.
Tous les fichier, heriteront de la configuration se trouvant dans base.py

Pour executer django avec une configuration particuliere,
on aura deux options

la premiere, preciser la config en ligne de commande:
$ python manage.py runserver --settings=wappa.settings.base

la seconde, definir une variable d'env utilisée par notre virtualenv:
- export DJANGO_SETTINGS_MODULE=wappa.settings.dev
- unset DJANGO_SETTINGS_MODULE

et plus besoin d'utiliser l'option --settings.
Faudra egalement voir comment automastier la creation de la varenv

dans les fichiers de configuration dev.py et test.py
DEBUG = True
TEMPLATE_DEBUG = True

dans le fichier de config prod.py
DEBUG = False
TEMPLATE_DEBUG = False

la cle secret ne doit pas apparaitre dans la configuration
il faudra donc supprimer la variable SECRET_KEY du fichier de config
base.py et la remplacer par une fonction lisant une varenv

from django.core.exceptions import ImproperlyConfigured

def get_env_variable(var_name):
    try:
        return os.environ[var_name]
    except KeyError:
        error_msg = "Set the %s environment variable" % var_name
        raise ImproperlyConfigured(error_msg)

SECRET_KEY = get_env_variable('SECRET_KEY')

Et donc:
en demarrant le virtualenv, il faudra faire
export SECRET_KEY=uneclésecrete

en desactivant le virtualenv, il faudra avant faire
unset SECRET_KEY

autre maniere de definir une cle secret, est de l'ecrire dans un fichier,
ce fichier ne doit pas etre versionné par git
- creer un fichier secret.txt dans le repertoire settings
- a l'interieur de ce fichier, coller la cle secret 'laclesecret'
- a l'interieur de base.py recuperer la cle secret en faisant:

def get_secret_from_file(secret_file):
    try:
        return open(os.path.join(BASE_DIR, secret_file)).read().strip()
    except KeyError:
        error_msg = "Secret file %s missing" % secret_file
        raise ImproperlyConfigured(error_msg)

SECRET_KEY = get_secret_from_file('settings/secret.txt')

Definir l'url via laquelle les fichiers statics seront servis.
modifier le fichier de configuration de base et ajouter:

STATIC_URL = '/static/'

Definir le repertoire dans lequel seront versés les fichiers
statiques. a l'appel de l'url plus haut, quel est le repertoire
où aller chercher les fichiers statiques? modifier le fichier
de configuration de base et ajouter:

STATICFILES_DIRS = (
    os.path.join(BASE_DIR, "static"),

)

Dans le repertoire "static", mettre les repertoire js, css, img.
eventuellement, un favicon.ico

il faudra ensuite appeler python manage.py collectstatic,
lorsque l'on sera en production.


Definir le repertoire dans lequel se trouvera tout le html. et un robot.txt.
Django cherchera un repertoire templates au niveau du projet,
puis au niveau de chaque application.

TEMPLATE_DIRS = (
    os.path.join(BASE_DIR, "templates"),

)

Les repertoires "templates" et "static" doivent exister,
au meme niveau que le repertoire "settings"

Transformer le repertoire functional_tests en module, en y
mettant un fichier vide nommé __init__.py
Ainsi, nous executerons les tests en tapant
python manage.py test functional_tests

tous les fichiers de tests a l'interieur du repertoire functiona_tests,
doivent etre prefixés par "test_"


Creation du modele de données:
------------------------------
Premiere chose, créer une application.
Toutes les applications de notre projet seront placées ds le repertoire apps.
ce repertoire se trouve au meme niveau que le fichier manage.py.

creer une application a la racine du projet:
python manage.py startapp photo

deplacer cette application dans le repertoire apps:
mv photo apps/; touch apps/__init__.py

puis editer le fichier de configuration base.py,
dans le tuple installed apps, ajouter une ligne: 'apps.photo', ainsi, django
sait qu'il doit tenir compte de la nouvelle application.

s'assurer que la racine du projet se trouve dans le python path,
autrement, django ne sera pas capable de reconnaitre le repertoire apps
comme etant un module

# the directory containing the manage.py file
ROOT_DIR = os.path.abspath(os.path.join(BASE_DIR, os.pardir))

# add ROOT_DIR to the python path
import sys
sys.path.append(ROOT_DIR)


le processus sera a peu pres le suivant:

editer le fichier models.py # pour mettre a jour le modele de données
python manage.py makemigrations # pour creer le script de migration
python manage.py migrate # pour appliquer les migration et ainsi modifier la bdd

Ensuite, il nous faut créer un admin, pour le backoffice:
python manage.py createsuperuser # a executer une et une seule fois bien sur :)


GESTION DES UPLOADS D'IMAGES:
-----------------------------
Voici la config a ajouter ds le fichier base.py

# Media files ( user uploaded contents)
# https://docs.djangoproject.com/en/1.7/ref/settings/#std:setting-MEDIA_ROOT
MEDIA_ROOT = "/var/www/wappa/media/"
MEDIA_URL = "/media/"

MEDIA_ROOT est le chemin vers le repertoire qui sera utilisé pour recevoir
les fichiers uploadés. Ce chemin doit exister et doit etre writable.

MEDIA_URL est l'url qui sera utilisée pour acceder a MEDIA_ROOT via http.
Doit toujours se terminer par un /

Pour servir des fichiers uploadés par les clients en mode DEBUG=True,
il suffit de modifier le fichier url.py et y ajouter:

from django.conf import settings
from django.conf.urls.static import static

urlpatterns = patterns('',
    # ... the rest of your URLconf goes here ...
    ) + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)



FIXTURES:
---------
- creer un repertoire fixtures dans chaque application
- a l'interieur de ce repertoire, placer un fichier initial_data.json
- a l'interieur de ce fichier, ecrire du json decrivant les données a inserer a chaque migrations
Par defaut, django ira chercher dans chaque application, le fameux fichier initial_data.json
et ensuite tentera d'inserer ces données ds les tables qu'il faut.

Il est egalement possible de sauvegarder une bdd dans un fichier fixtures.
- python manage.py dumpdata photo --format json --indent 2 --natural-foreign > path/to/initial_data.json
Ce qui permet par exemple d'echanger la bdd entre devs de la meme equipe.
Ces derniers devront faire:
- python manage.py loaddata path/to/initial_data.json
et les données seront inserées ds la bdd

Enfin, il est egalement possible de definir un repetoire fixtures custom.
Il suffit de modifier le fichier base.py en y ajoutant quelque chose comme:
FIXTURE_DIRS = (
    normpath(join(SITE_ROOT, 'fixtures')),

)
Et ainsi, plus besoin de preciser le chemin a chaque fois que l'on veut importer


INTERNATIONALIZATION / LOCALIZATION
-----------------------------------
i18n: art de preparer le projet a la localisation.
l10n: ecrire les traductions

s'assurer d'avoir installé gettext.
http://ftp.gnu.org/pub/gnu/gettext/gettext-0.19.3.tar.xz

modifier le fichire base.py et veiller a avoir la ligne:
USE_I18N = True

Pour configurer l'internationalization, il faut egalement
configurer les template_context_processors. Ou pas,
django en utilise deja certains par defaut, si rien n'est
defini ds base.py

("django.contrib.auth.context_processors.auth",
"django.core.context_processors.debug",
"django.core.context_processors.i18n",
"django.core.context_processors.media",
"django.core.context_processors.static",
"django.core.context_processors.tz",
"django.contrib.messages.context_processors.messages")

Il n'y a donc rien a faire, si ce n'est verifier en
lançant une console python et afficher la valeur par
defaut:

$ python manage.py shell
>>> from django.conf import settings
>>> settings.TEMPLATE_CONTEXT_PROCESSORS

les templates context processors nous aideront
a ecrire des tags que nous utiliserons ds les
templates. exemple, ecrire un tag qui recupere
une variable ds le fichier settings. nous y
reviendrons.

toujours pour configurer i18n/l10n,
veiller a ce que le middleware Locale soit là.
Il faut veiller a le placer apres sessionmidleware
et avant commonmiddleware car l'ordre importe.
Et si cachemiddleware est present, localemiddleware
doit etre placé apres.

MIDDLEWARE_CLASSES = (
  ...
  'django.middleware.locale.LocaleMiddleware'
)

Les middlewares permettent d'alterer le cycle
requete/reponse de django grace a des hooks.

specifier egalement les langages dans lesquels
on va faire les traductions

from django.utils.translation import ugettext_lazy as _
# http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
LANGUAGES = (
    ('en', _('English')),
    ('de', _('German')),
    ('fr', _('French')),
)

Ici, la fonction underscore alias de la fonction
ugettext_lazy, est utilisée pour "marquer" le nom
de la langue pour traduction. ugettext_lazy ne fera
de traductions qu'au moment de rendre le template

si aucune traduction trouvée,
traduction par defaut: utiliser en
LANGUAGE_CODE = 'en-us'

# le chemin vers le repertoire contenant les trads
LOCALE_PATHS = (
    os.path.join(BASE_DIR, 'locale'),

)

Ensuite, il faut mettre a jour le fichier urls.py

from django.conf.urls import patterns, include, url
from django.contrib import admin
from django.conf.urls.i18n import i18n_patterns
from apps.photo.views import home, home_files

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'wappa.views.home', name='home'),
    # url(r'^blog/', include('blog.urls')),
    url(r'^(?P<filename>(robots.txt)|(humans.txt))$',
                        home_files,name='home-files'),
                        )

urlpatterns += i18n_patterns(
    '',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^$', home, name='home'),
)

en gros, les urls admin/ et / vont etre gerée de
maniere automagique. / deviendra /en/ par defaut,
et admin/ deviendra /en/admin/ par defaut.
Parce que mon navigateur prefere naviger en anglais.

Sur un navigateur preferant naviguer en français,
le prefixe fr/ sera ajouté a la place de en/

Dans le cas où le navigateur ne donne pas sa preference,
LANGUAGE_CODE determinera la langue a utiliser.

les urls que nous voulons soumettre a la traduction
doivent etre misent ds le tuple i18n_patterns

les fichiers robots et humans ne seront pas soumis
a cette gestion automagique d'urls.

Pour generer les fichiers contenant les traductions.
Se mettre a la racine du projet a cote de manage.py
et taper:

python manage.py makemessages -l en
python manage.py makemessages -l fr
python manage.py makemessages -l de

J'utilise une version de django ayant un leger bug.
le bug a deja ete fixé, je dois mettre a jour django.
Pour que les trois commandes precedentes fonctionnent,
en attendant de maj django, je dois avoir dans base.py

STATIC_ROOT = '/var/www/wappa/static/'

Les fichiers de traductions sont tous dans:

wappa/locales/en/LC_MESSAGES/django.po
wappa/locales/fr/LC_MESSAGES/django.po
wappa/locales/de/LC_MESSAGES/django.po
